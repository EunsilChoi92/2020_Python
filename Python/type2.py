'''
[3.리스트(list)]
    - 데이터(값)들의 목록
    - 편리하다.

    리스트명(변수) = [요소1,요소2,요소3.....]
    
'''
print("="*20)
print("{:^20}".format("LIST"))
print("="*20)

print("[리스트 만들기]")
a = [] #요소가 없는 빈 리스트
b = [1,2,3] #요소가 정수
c = ["A","B","C"]#문자열
d = [1,2,"A","B"]#혼합
e = [1,"A",[2,"B"]]#혼합 + 리스트 안에 또 리스트

#d,e는 바람직한 형태 X(문법적으로는 문제 없음)
#리스트를 사용하겠다 = 관련있는 자료끼리 묶겠다
print(a)
print(c)
print(c)
print(d)
print(e)

#type : 자료의 종류를 확인
print("변수 a의 type :",type(a))
print("1의 type :",type(1))

print("[리스트 인덱싱,슬라이싱]")
#문자열 : 하나 하나 문자들이 순서대로 나열된 형태
#리스트 : 하나 하나 요소들이 순서대로 저장된 형태
# 순서가 있다 : 인덱싱 슬라이싱 가능

my_list = ["한수창","홍길동","이몽룡"]
print(my_list)
print("첫번째 사람은 "+my_list[0])
#리스트의 첫 번째 요소가 '문자열'이기 때문에
#인덱싱해서 가져온 값은 그대로 '문자열'이다.

num_list = [1,2,3]
print("첫번째 요소 : ",num_list[0])
#요소가 '정수'이기 때문에, 인덱싱의 결과도 '정수'

#인덱싱 비교
#문자열 : 모든 요소가 문자이기 때문에 인덱싱하면 다 '문자'
#리스트 : 각 요소의 형태에 따라 인덱싱 결과가 다르다.

#이중 리스트 인덱싱(리스트 안에 리스트를 요소로 가짐)
my_list = ["한수창","홍길동",["임꺽정","이몽룡"]]
print(my_list[2])
print(my_list[2][1])
#인덱스 범위초과, 음수 사용 문자열 인덱싱과 동일

a = [2,"2"]
print(a[0]*2)
print(a[1]*2)

#슬라이싱도 동일
print(a[0:2])
print(a[0:1])#요소가 하나여도 '슬라이싱 결과'는 '리스트'
#무조건 리스트
print(a[0])

print("[리스트 연산하기]")
a = [1,2,3]
b = [4,5,6]
print("리스트 덧셈 :",a+b)#연결
print("리스트 곱셈 :",a*2)#반복

#->하나의 새로운 리스트 생성

c = a + b
print(c)
print(type(c))

print("[리스트 수정하기(변경,삭제]")
#문자열은 수정 X

a = [1,2,3,4,5,6]
a[2] = -1
print("변경 후 :",a)
#연속된 볌위의 값을 수정
#a[0:2] = 0 # 오류 ! 슬라이싱의 결과는 ' 리스트 '
a[0:2] = [0]
print("변경 후 :",a)
#0,1(첫번째,두번째) 요소를 [0]으로 변경

a[0:2] = [6,7,8]
print("변경 후 :",a)

#인덱싱
a[0] = [1,2]#첫번째 요소에 '리스트' 대입
print("변경 후 :",a)

#삭제
a[0] = []#삭제가 아님. 빈 리스트 대입
print("변경 후 :",a)

del(a[0])#해당 요소 제거
print("변경 후 :",a)

a[0:2] = []#슬라이싱을 하여 빈 리스트 대입하면 제거
print("변경 후 :",a)

del(a[0:1])
print("변경 후 :",a)

del(a)
#print("변경 후 :",a)

print("[리스트 관련 함수]")
#리스트.함수()

a = [1,2,3]

#append(value) : 리스트 가장 뒤에 value를 추가

a.append(4)
print("append(4) : ",a)
a.append([5,6])
print("a =",a)
#append는 '하나' 요소만 추가 가능

#sort() : 리스트 정렬 (숫자,알파벳 등)
a = [9,2,8,1]
print("a =",a)
a.sort()#a 리스트 자체가 변경
print("a =",a)#기본 오름차순
a.sort(reverse=True)#내림차순(정렬 후 결과를 뒤집는다)
print("a = ",a)
#True 는 뒤에서 배울 '자료향' / 참(진실)을 의미하는 '값'
#반대로는 False(거짓)이 있다.

#sort와 sorted
#a.sort() : a자체가 정렬(a가 주체)
#sorted(a) : a를 정렬한 새로운 리스트 생성(a는 도구)

a = [3,1,2]
b = sorted(a)
print(a)
print(b)


#reverse() : 리스트 뒤집기(정렬 X , 현재 요소를 그대로 뒤집는다)
a = [9,2,8,1]
a.reverse()
print("a =",a)

#index() : 리스트에서 요소를 찾고 그 위치 반환
a = [1,2,3]
print("a에서 2의 위치 :",a.index(2))

#insert(index,value) : 지정한 위치에 값 삽입
a.insert(1,"뿅")
print("변경 후 :",a)

#append = "맨 뒤에 값 추가"
#insert = 지정한 위치에 추가

#remove(): 리스트에서 처음 찾은 값 제거
a = [1,2,3,1]
a.remove(1)
print("a =",a)

#a[0] = [] : 첫 번째 요소를 '빈 리스트'로 변경
#del(a[0]) : 첫 번째 요소를 제거(0은 순서)
#a.remove(0) : 정수 0을 찾아서 제거(0은 값)

#count() : 리스트에 존재하는 요소의 개수 반환
a = [1,2,3,1,2,3,1,2,3,1,1,2,3,1,2,3,1,2,3]

print("a 에서 2의 개수 :",a.count(2))
#없다면 0

#pop은 '리스트' 개념에서 매우 중요
#pop(index) : 리스트에서 (index)번째 값을 '뽑아낸다'
# 1. 뽑아낸 값을 '반환'해준다(어떤 값이지 가르쳐준다)
#   >우리가 사용할 수 있다.(변수에 대입/어딘가에 사용)
# 2. 리스트에서 해당 값을 제거(뽑아내는 개념)

a = [1,2,3,1]
print("a.pop(1) =",a.pop(1))
print("a =",a)

print("a.pop() =",a.pop())#index를 사용하지 않으면 기본 맨 뒤
print("a =",a)

#len() : 요소를 개수를 구하는 함수
a = [1,2,3,4]
b = "1234"
c = 1234
#c[0] = 1

print("len(a) =",len(a))
print("len(b) =",len(b))
#print("len(c) =",len(c))

#a = 리스트 = '어떤' 값들이 여러개 존재
#b = 문자열 = '문자'들이 여러개 존재
#c = 정수   = '단' 하나의 숫자(값)
#값이 여러개 존재하는 자료형만 len() 사용 가능

#copy() : 모든 값들을 '복제'하여 새로운 리스트 생성
a = [1,2,3,4]
b = a.copy()
c = a

print("기존 a :",a)
print("복제 b :",b)
print("대입 c :",c)

#c = a를 했을 때, 이미 만들어진 a 리스트를 c와 같이 가르킨다.
b[0] = -10
c[0] = -20

print("기존 a :",a)
print("복제 b :",b)
print("대입 c :",c)

#clear():리스트의 모든 요소 제거
a.clear()
print("a =",a)
#리스트가 삭제 X(요소만 제거)

#list의 요소들이 "문자열"로만 이루어진 경우
#문자열 관련 함수 중 join을 이용하여 하나의 문자열 생성 가능

my_list = ["대","한","민","국"]
my_str = "".join(my_list)
print(my_str)

print(",".join("하하하"))


'''
    리스트 인덱싱 연습하기
    2018년 새해가 밝았습니다. 내년은 2019년 입니다.
'''
#     0         1       2       [3][0]      [3][1]      [4]     [5][0]
a = [2018, "입니다.", "새해", [" 내년", "가 밝았습니다."], "은 ", ["년 "]]

print(a[0],a[5][0],a[2],a[3][1],a[3][0],a[4],a[0]+1,a[1],sep='')

'''
    리스트 활용 연습하기
      my_list를 이용하여 "안녕하세요!" 문자열을 만들고 출력하기
      join() 함수 활용

'''
my_list = [ "!", "요", "세", "요", "하", "녕", "안" ]


my_list.reverse()
my_list.remove("요")
new_str = "".join(my_list)
print(my_list)
print(new_str)

'''
[4.튜플(Tuple) 자료형]
    리스트와 비슷
        -차이점
            1.생성법
                리스트 []
                튜플 ()
            2.튜플은 한 번 만들면 변경 불가
                >마치 문자열처럼...

            -프로그램이 수행되는 동안 요소가 변경되지 않게 하고 싶다면
            리스트 대신 튜플을 사용한다.
            일반적으로 '리스트' 사용
            
'''
print("="*20)
print("{:^20}".format("Tuple"))
print("="*20)
print("[튜플 만들기]")
a = () #빈튜플(쓸모없음)
b = (1,)#요소가 1개일 땐 뒤에 콤마를 붙인다.
c = (1,2,3,"A","B","C")
d = 1,2,3#() 생략해도 튜플
#a,b,c = 1,2,3 #이코드는 변수에 순서대로 대입
e = (1,"A",(2,"B"))

print("d의 type :" ,type(d))
print()

print("[튜플은 변경불가]")
a = 1,2,3,4

print(a)
print(a[0])
print(a[0:2])#슬라이싱 가능(슬라이싱 결과는 '튜플')

#a[0] = -1#오류! 튜플의 요소 변경 불가(문자열처럼)
#del(a[0])#삭제 불가

a = 1,2,3,4
b = 5,6,7,8

c = a + b
print(c*2)





























